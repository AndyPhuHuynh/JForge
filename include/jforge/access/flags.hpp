#pragma once

#include <cstdint>
#include <type_traits>

namespace jforge::access
{
    enum class Class : uint16_t
    {
        Public	    = 0x0001, // Declared public; may be accessed from outside its package.
        Final	    = 0x0010, // Declared final; no subclasses allowed.
        Super	    = 0x0020, // Treat superclass methods specially when invoked by the invokespecial instruction.
        Interface   = 0x0200, // Is an interface, not a class.
        Abstract    = 0x0400, // Declared abstract; must not be instantiated.
        Synthetic   = 0x1000, // Declared synthetic; not present in the source code.
        Annotation  = 0x2000, // Declared as an annotation interface.
        Enum        = 0x4000, // Declared as an enum class.
        Module      = 0x8000, // Is a module, not a class or interface.
    };

    enum class Method : uint16_t
    {
        Public       = 0x0001, // Declared public; may be accessed from outside its package.
        Private	     = 0x0002, // Declared private; accessible only within the defining class and other classes belonging to the same nest.
        Protected    = 0x0004, // Declared protected; may be accessed within subclasses.
        Static       = 0x0008, // Declared static.
        Final        = 0x0010, // Declared final; must not be overridden.
        Synchronized = 0x0020, // Declared synchronized; invocation is wrapped by a monitor use.
        Bridge       = 0x0040, // A bridge method, generated by the compiler.
        VarArgs	     = 0x0080, // Declared with variable number of arguments.
        Native       = 0x0100, // Declared native; implemented in a language other than the Java programming language.
        Abstract     = 0x0400, // Declared abstract; no implementation is provided.
        Strict       = 0x0800, // In a class file whose major version number is at least 46 and at most 60: Declared strictfp.
        Synthetic    = 0x1000, // Declared synthetic; not present in the source code.
    };

    constexpr Method operator|(Method lhs, Method rhs) noexcept {
        using T = std::underlying_type_t<Method>;
        return static_cast<Method>(static_cast<T>(lhs) | static_cast<T>(rhs));
    }

    constexpr Method operator&(Method lhs, Method rhs) noexcept {
        using T = std::underlying_type_t<Method>;
        return static_cast<Method>(static_cast<T>(lhs) & static_cast<T>(rhs));
    }

    constexpr bool any(Method flag, Method mask) noexcept {
        using T = std::underlying_type_t<Method>;
        return (static_cast<T>(flag) & static_cast<T>(mask)) != 0;
    }
}
